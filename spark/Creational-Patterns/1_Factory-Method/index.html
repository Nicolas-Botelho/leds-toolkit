<!DOCTYPE html><meta charset="utf-8"><h1 id="factory-method-pattern-in-the-project-structure">Factory Method Pattern in the Project Structure</h1><p>We used the <strong>Factory Method design pattern</strong> to organize and structure the generation of different parts of the system. The main idea was to create a <strong>modular and reusable</strong> way to generate files based on a common model, keeping the code organized, flexible, and easy to understand.</p><hr><h2 id="structure-i-implemented">Structure I Implemented</h2><p>The structure is composed of 4 main parts:</p><h3 id="1-abstract-class-abstractgeneratorfactory">1. Abstract Class: <code>AbstractGeneratorFactory</code></h3><p>I created a base class called <code>AbstractDocumentationGeneratorFactory</code>, which defines a method <code>generate()</code>. This method:</p><ul><li>Creates the folder where the files will be generated.</li><li>Calls an abstract method called <code>createGenerators()</code> — which is the <strong>actual factory method</strong>.</li><li>Then, executes the <code>generate()</code> method of each returned generator.</li></ul><p>This <code>generate()</code> method controls the <strong>common generation flow</strong>, and I didn’t have to repeat this logic for each generator type.</p><hr><h3 id="2-factory-method-creategenerators">2. Factory Method: <code>createGenerators()</code></h3><p>This method is abstract and implemented by the subclasses.<br>Each subclass represents a specific “factory”, such as:</p><ul><li><code>StandardDocumentationGeneratorFactory</code> – responsible for generating documentation files.</li><li>In other parts of the project, I have factories that generate entities or webservices as well.</li></ul><p>Each factory knows <strong>which concrete generators</strong> it needs to instantiate.</p><hr><h3 id="3-common-interface-ijavagenerator">3. Common Interface: <code>IJavaGenerator</code></h3><p>All my concrete generators implement the <code>IJavaGenerator</code> interface, which requires them to have a <code>generate(model, targetFolder)</code> method. This ensures that any generator, regardless of what it produces, can be used interchangeably.</p><hr><h3 id="4-concrete-generators">4. Concrete Generators</h3><p>I have several concrete classes that handle the actual file generation.<br>One example is <code>DocumentationGenerator</code>, which creates files like <code>README.md</code> and <code>.gitlab-ci.yml</code>.<br>But I also have generators like <code>EntityGenerator</code>, <code>ControllerGenerator</code>, among others.</p>